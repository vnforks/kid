// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package store

import (
	"context"
	timemodule "time"

	"github.com/vnforks/kid/v5/einterfaces"
	"github.com/vnforks/kid/v5/model"
)

type TimerLayer struct {
	Store
	Metrics                 einterfaces.MetricsInterface
	AuditStore              AuditStore
	BranchStore             BranchStore
	ClassStore              ClassStore
	ClusterDiscoveryStore   ClusterDiscoveryStore
	CommandStore            CommandStore
	CommandWebhookStore     CommandWebhookStore
	ComplianceStore         ComplianceStore
	EmojiStore              EmojiStore
	FileInfoStore           FileInfoStore
	JobStore                JobStore
	LicenseStore            LicenseStore
	LinkMetadataStore       LinkMetadataStore
	OAuthStore              OAuthStore
	PostStore               PostStore
	PreferenceStore         PreferenceStore
	ReactionStore           ReactionStore
	RoleStore               RoleStore
	SchemeStore             SchemeStore
	SessionStore            SessionStore
	StatusStore             StatusStore
	SystemStore             SystemStore
	TermsOfServiceStore     TermsOfServiceStore
	TokenStore              TokenStore
	UserStore               UserStore
	UserAccessTokenStore    UserAccessTokenStore
	UserTermsOfServiceStore UserTermsOfServiceStore
	WebhookStore            WebhookStore
}

func (s *TimerLayer) Audit() AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) Branch() BranchStore {
	return s.BranchStore
}

func (s *TimerLayer) Class() ClassStore {
	return s.ClassStore
}

func (s *TimerLayer) ClusterDiscovery() ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Command() CommandStore {
	return s.CommandStore
}

func (s *TimerLayer) CommandWebhook() CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *TimerLayer) Compliance() ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) Emoji() EmojiStore {
	return s.EmojiStore
}

func (s *TimerLayer) FileInfo() FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Job() JobStore {
	return s.JobStore
}

func (s *TimerLayer) License() LicenseStore {
	return s.LicenseStore
}

func (s *TimerLayer) LinkMetadata() LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *TimerLayer) OAuth() OAuthStore {
	return s.OAuthStore
}

func (s *TimerLayer) Post() PostStore {
	return s.PostStore
}

func (s *TimerLayer) Preference() PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) Reaction() ReactionStore {
	return s.ReactionStore
}

func (s *TimerLayer) Role() RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) Scheme() SchemeStore {
	return s.SchemeStore
}

func (s *TimerLayer) Session() SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) Status() StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) System() SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) TermsOfService() TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Token() TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) User() UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) UserTermsOfService() UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *TimerLayer) Webhook() WebhookStore {
	return s.WebhookStore
}

type TimerLayerAuditStore struct {
	AuditStore
	Root *TimerLayer
}

type TimerLayerBranchStore struct {
	BranchStore
	Root *TimerLayer
}

type TimerLayerClassStore struct {
	ClassStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCommandStore struct {
	CommandStore
	Root *TimerLayer
}

type TimerLayerCommandWebhookStore struct {
	CommandWebhookStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	ComplianceStore
	Root *TimerLayer
}

type TimerLayerEmojiStore struct {
	EmojiStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	FileInfoStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	JobStore
	Root *TimerLayer
}

type TimerLayerLicenseStore struct {
	LicenseStore
	Root *TimerLayer
}

type TimerLayerLinkMetadataStore struct {
	LinkMetadataStore
	Root *TimerLayer
}

type TimerLayerOAuthStore struct {
	OAuthStore
	Root *TimerLayer
}

type TimerLayerPostStore struct {
	PostStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	PreferenceStore
	Root *TimerLayer
}

type TimerLayerReactionStore struct {
	ReactionStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	RoleStore
	Root *TimerLayer
}

type TimerLayerSchemeStore struct {
	SchemeStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	SessionStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	StatusStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	SystemStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	TokenStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerUserTermsOfServiceStore struct {
	UserTermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerWebhookStore struct {
	WebhookStore
	Root *TimerLayer
}

func (s *TimerLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.AuditStore.Get(user_id, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.AuditStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerAuditStore) Save(audit *model.Audit) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.AuditStore.Save(audit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) AnalyticsBranchCount(includeDeleted bool) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.AnalyticsBranchCount(includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.AnalyticsBranchCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) AnalyticsGetBranchCountForScheme(schemeId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.AnalyticsGetBranchCountForScheme(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.AnalyticsGetBranchCountForScheme", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) ClearAllCustomRoleAssignments() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) ClearCaches() {
	start := timemodule.Now()

	s.BranchStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerBranchStore) Get(id string) (*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetActiveMemberCount(branchId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetActiveMemberCount(branchId, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetActiveMemberCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetAll() ([]*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetAllForExportAfter(limit int, afterId string) ([]*model.BranchForExport, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetAllForExportAfter(limit, afterId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetAllForExportAfter", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetAllPage(offset int, limit int) ([]*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetAllPage", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBranchMembersForExport(userId string) ([]*model.BranchMemberForExport, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBranchMembersForExport(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBranchMembersForExport", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBranchesByScheme(schemeId string, offset int, limit int) ([]*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBranchesByScheme(schemeId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBranchesByScheme", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBranchesByUserId(userId string) ([]*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBranchesByUserId(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBranchesByUserId", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBranchesForUser(userId string) ([]*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBranchesForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBranchesForUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBranchesForUserWithPagination(userId string, page int, perPage int) ([]*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBranchesForUserWithPagination(userId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBranchesForUserWithPagination", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetByName(name string) (*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetByNames(name []string) ([]*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetByNames(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetByNames", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetBySchoolId(schoolId string) (*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetBySchoolId(schoolId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetBySchoolId", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetMember(branchId string, userId string) (*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetMember(branchId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetMembers(branchId string, offset int, limit int, branchMembersGetOptions *model.BranchMembersGetOptions) ([]*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetMembers(branchId, offset, limit, branchMembersGetOptions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetMembers", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetMembersByIds(branchId string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetMembersByIds(branchId, userIds, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetMembersByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetTotalMemberCount(branchId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetTotalMemberCount(branchId, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetTotalMemberCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) GetUserBranchIds(userId string, allowFromCache bool) ([]string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.GetUserBranchIds(userId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.GetUserBranchIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) InvalidateAllBranchIdsForUser(userId string) {
	start := timemodule.Now()

	s.BranchStore.InvalidateAllBranchIdsForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.InvalidateAllBranchIdsForUser", success, elapsed)
	}
}

func (s *TimerLayerBranchStore) MigrateBranchMembers(fromBranchId string, fromUserId string) (map[string]string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.MigrateBranchMembers(fromBranchId, fromUserId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.MigrateBranchMembers", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) PermanentDelete(branchId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.PermanentDelete(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.PermanentDelete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) RemoveAllMembersByBranch(branchId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.RemoveAllMembersByBranch(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.RemoveAllMembersByBranch", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) RemoveAllMembersByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.RemoveAllMembersByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.RemoveAllMembersByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) RemoveMember(branchId string, userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.RemoveMember(branchId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.RemoveMember", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) ResetAllBranchSchemes() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.ResetAllBranchSchemes()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.ResetAllBranchSchemes", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) Save(branch *model.Branch) (*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.Save(branch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) SaveMember(member *model.BranchMember, maxUsersPerBranch int) (*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.SaveMember(member, maxUsersPerBranch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.SaveMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) Update(branch *model.Branch) (*model.Branch, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.Update(branch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) UpdateLastBranchIconUpdate(branchId string, curTime int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.UpdateLastBranchIconUpdate(branchId, curTime)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.UpdateLastBranchIconUpdate", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) UpdateMember(member *model.BranchMember) (*model.BranchMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.UpdateMember(member)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.UpdateMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerBranchStore) UpdateMembersRole(branchID string, userIDs []string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.BranchStore.UpdateMembersRole(branchID, userIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.UpdateMembersRole", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerBranchStore) UserBelongsToBranches(userId string, branchIds []string) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.BranchStore.UserBelongsToBranches(userId, branchIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BranchStore.UserBelongsToBranches", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) ClearAllCustomRoleAssignments() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) ClearCaches() {
	start := timemodule.Now()

	s.ClassStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerClassStore) CreateDirectClass(userId *model.User, otherUserId *model.User) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.CreateDirectClass(userId, otherUserId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.CreateDirectClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) Delete(classId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.Delete(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) Get(id string, allowFromCache bool) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAll(branchId string) ([]*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAll(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAllClassMembersForUser(userId string, allowFromCache bool, includeDeleted bool) (map[string]string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAllClassMembersForUser(userId, allowFromCache, includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAllClassMembersForUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAllClassMembersNotifyPropsForClass(classId string, allowFromCache bool) (map[string]model.StringMap, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAllClassMembersNotifyPropsForClass(classId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAllClassMembersNotifyPropsForClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAllClasses(page int, perPage int, opts ClassSearchOpts) (*model.ClassListWithBranchData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAllClasses(page, perPage, opts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAllClasses", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAllClassesCount(opts ClassSearchOpts) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAllClassesCount(opts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAllClassesCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetAllClassesForExportAfter(limit int, afterId string) ([]*model.ClassForExport, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetAllClassesForExportAfter(limit, afterId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetAllClassesForExportAfter", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetBranchClasses(branchId string) (*model.ClassList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetBranchClasses(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetBranchClasses", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetByName(branch_id string, name string, allowFromCache bool) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetByName(branch_id, name, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetByNameIncludeDeleted(branch_id string, name string, allowFromCache bool) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetByNameIncludeDeleted(branch_id, name, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetByNameIncludeDeleted", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetByNames(branch_id string, names []string, allowFromCache bool) ([]*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetByNames(branch_id, names, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetByNames", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClassMembersForExport(userId string, branchId string) ([]*model.ClassMemberForExport, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClassMembersForExport(userId, branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClassMembersForExport", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClassMembersTimezones(classId string) ([]model.StringMap, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClassMembersTimezones(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClassMembersTimezones", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClasses(branchId string, userId string, includeDeleted bool) (*model.ClassList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClasses(branchId, userId, includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClasses", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClassesBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClassesBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClassesBatchForIndexing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClassesByIds(classIds []string, includeDeleted bool) ([]*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClassesByIds(classIds, includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClassesByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetClassesByScheme(schemeId string, offset int, limit int) (model.ClassList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetClassesByScheme(schemeId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetClassesByScheme", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetDeleted(branch_id string, offset int, limit int, userId string) (*model.ClassList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetDeleted(branch_id, offset, limit, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetDeleted", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetDeletedByName(branch_id string, name string) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetDeletedByName(branch_id, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetDeletedByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetForPost(postId string) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetForPost(postId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetForPost", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetFromMaster(id string) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetFromMaster(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetFromMaster", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMember(classId string, userId string) (*model.ClassMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMember(classId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMemberCount(classId string, allowFromCache bool) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMemberCount(classId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMemberCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMemberCountFromCache(classId string) int64 {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.GetMemberCountFromCache(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMemberCountFromCache", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) GetMemberForPost(postId string, userId string) (*model.ClassMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMemberForPost(postId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMemberForPost", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMembers(classId string, offset int, limit int) (*model.ClassMembers, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMembers(classId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMembers", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMembersByIds(classId string, userIds []string) (*model.ClassMembers, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMembersByIds(classId, userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMembersByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMembersForUser(branchId string, userId string) (*model.ClassMembers, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMembersForUser(branchId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMembersForUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMembersForUserWithPagination(branchId string, userId string, page int, perPage int) (*model.ClassMembers, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMembersForUserWithPagination(branchId, userId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMembersForUserWithPagination", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) GetMoreClasses(branchId string, userId string, offset int, limit int) (*model.ClassList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.GetMoreClasses(branchId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.GetMoreClasses", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) InvalidateAllClassMembersForUser(userId string) {
	start := timemodule.Now()

	s.ClassStore.InvalidateAllClassMembersForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.InvalidateAllClassMembersForUser", success, elapsed)
	}
}

func (s *TimerLayerClassStore) InvalidateCacheForClassMembersNotifyProps(classId string) {
	start := timemodule.Now()

	s.ClassStore.InvalidateCacheForClassMembersNotifyProps(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.InvalidateCacheForClassMembersNotifyProps", success, elapsed)
	}
}

func (s *TimerLayerClassStore) InvalidateClass(id string) {
	start := timemodule.Now()

	s.ClassStore.InvalidateClass(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.InvalidateClass", success, elapsed)
	}
}

func (s *TimerLayerClassStore) InvalidateClassByName(branchId string, name string) {
	start := timemodule.Now()

	s.ClassStore.InvalidateClassByName(branchId, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.InvalidateClassByName", success, elapsed)
	}
}

func (s *TimerLayerClassStore) InvalidateMemberCount(classId string) {
	start := timemodule.Now()

	s.ClassStore.InvalidateMemberCount(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.InvalidateMemberCount", success, elapsed)
	}
}

func (s *TimerLayerClassStore) IsUserInClassUseCache(userId string, classId string) bool {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.IsUserInClassUseCache(userId, classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.IsUserInClassUseCache", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) MigrateClassMembers(fromClassId string, fromUserId string) (map[string]string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.MigrateClassMembers(fromClassId, fromUserId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.MigrateClassMembers", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) PermanentDelete(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.PermanentDelete(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.PermanentDelete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) PermanentDeleteByBranch(branchId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.PermanentDeleteByBranch(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.PermanentDeleteByBranch", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) PermanentDeleteMembersByClass(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.PermanentDeleteMembersByClass(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.PermanentDeleteMembersByClass", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) PermanentDeleteMembersByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.PermanentDeleteMembersByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.PermanentDeleteMembersByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) RemoveAllDeactivatedMembers(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.RemoveAllDeactivatedMembers(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.RemoveAllDeactivatedMembers", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) RemoveMember(classId string, userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.RemoveMember(classId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.RemoveMember", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) ResetAllClassSchemes() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.ResetAllClassSchemes()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.ResetAllClassSchemes", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) Restore(classId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.Restore(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.Restore", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) Save(class *model.Class, maxClassesPerBranch int64) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.Save(class, maxClassesPerBranch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) SaveDirectClass(class *model.Class, member1 *model.ClassMember, member2 *model.ClassMember) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.SaveDirectClass(class, member1, member2)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.SaveDirectClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) SaveMember(member *model.ClassMember) (*model.ClassMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.SaveMember(member)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.SaveMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) SetDeleteAt(classId string, deleteAt int64, updateAt int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.SetDeleteAt(classId, deleteAt, updateAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.SetDeleteAt", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) Update(class *model.Class) (*model.Class, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.Update(class)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) UpdateMember(member *model.ClassMember) (*model.ClassMember, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.UpdateMember(member)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.UpdateMember", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClassStore) UpdateMembersRole(classID string, userIDs []string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClassStore.UpdateMembersRole(classID, userIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.UpdateMembersRole", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClassStore) UserBelongsToClasses(userId string, classIds []string) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClassStore.UserBelongsToClasses(userId, classIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClassStore.UserBelongsToClasses", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerCommandStore) AnalyticsCommandCount(branchId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.AnalyticsCommandCount(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.AnalyticsCommandCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandStore) Delete(commandId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.CommandStore.Delete(commandId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerCommandStore) Get(id string) (*model.Command, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandStore) GetByBranch(branchId string) ([]*model.Command, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.GetByBranch(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandStore) GetByTrigger(branchId string, trigger string) (*model.Command, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.GetByTrigger(branchId, trigger)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByTrigger", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandStore) PermanentDeleteByBranch(branchId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.CommandStore.PermanentDeleteByBranch(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByBranch", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerCommandStore) PermanentDeleteByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.CommandStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerCommandStore) Save(webhook *model.Command) (*model.Command, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.Save(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandStore) Update(hook *model.Command) (*model.Command, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandStore.Update(hook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandWebhookStore) Cleanup() {
	start := timemodule.Now()

	s.CommandWebhookStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandWebhookStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.CommandWebhookStore.Save(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerCommandWebhookStore) TryUse(id string, limit int) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.CommandWebhookStore.TryUse(id, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.TryUse", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerComplianceStore) ComplianceExport(compliance *model.Compliance) ([]*model.CompliancePost, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.ComplianceExport(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.ComplianceExport", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerComplianceStore) Get(id string) (*model.Compliance, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerComplianceStore) MessageExport(after int64, limit int) ([]*model.MessageExport, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.MessageExport(after, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.MessageExport", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.Save(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ComplianceStore.Update(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) Delete(emoji *model.Emoji, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.EmojiStore.Delete(emoji, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerEmojiStore) Get(id string, allowFromCache bool) (*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) GetByName(name string, allowFromCache bool) (*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.GetByName(name, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.GetList(offset, limit, sort)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetList", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) GetMultipleByName(names []string) ([]*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.GetMultipleByName(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetMultipleByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.Save(emoji)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.EmojiStore.Search(name, prefixOnly, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Search", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) AttachToPost(fileId string, postId string, creatorId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.FileInfoStore.AttachToPost(fileId, postId, creatorId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.AttachToPost", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := timemodule.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) DeleteForPost(postId string) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.DeleteForPost(postId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.DeleteForPost", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) Get(id string) (*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.GetByPath(path)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByPath", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) GetForPost(postId string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForPost", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) GetForUser(userId string) ([]*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.GetForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPostCache(postId string, deleted bool) {
	start := timemodule.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postId, deleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(fileId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.FileInfoStore.PermanentDelete(fileId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(userId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.FileInfoStore.Save(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) Delete(id string) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) Get(id string) (*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetAllByStatus(status string) ([]*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetAllByStatus(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByStatus", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetAllByType(jobType string) ([]*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetAllByType(jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByType", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypePage", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllPage", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetCountByStatusAndType", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) Save(job *model.Job) (*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status string) (*model.Job, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerLicenseStore) Get(id string) (*model.LicenseRecord, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.LicenseStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.LicenseStore.Save(license)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.LinkMetadataStore.Get(url, timestamp)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.LinkMetadataStore.Save(linkMetadata)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) DeleteApp(id string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.OAuthStore.DeleteApp(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.DeleteApp", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerOAuthStore) GetAccessData(token string) (*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAccessData(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByRefreshToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByRefreshToken", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetAccessDataByUserForApp(userId string, clientId string) ([]*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByUserForApp", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetApp(id string) (*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetApp(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApp", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetAppByUser(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAppByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAppByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetApps(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApps", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetAuthData(code string) (*model.AuthData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAuthData(code)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetAuthorizedApps(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetAuthorizedApps(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthorizedApps", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) GetPreviousAccessData(userId string, clientId string) (*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.GetPreviousAccessData(userId, clientId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetPreviousAccessData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) PermanentDeleteAuthDataByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.OAuthStore.PermanentDeleteAuthDataByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.PermanentDeleteAuthDataByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerOAuthStore) RemoveAccessData(token string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.OAuthStore.RemoveAccessData(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAccessData", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerOAuthStore) RemoveAllAccessData() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.OAuthStore.RemoveAllAccessData()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAllAccessData", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerOAuthStore) RemoveAuthData(code string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.OAuthStore.RemoveAuthData(code)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAuthData", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.SaveAccessData(accessData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAccessData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.SaveApp(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveApp", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.SaveAuthData(authData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAuthData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.UpdateAccessData(accessData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateAccessData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.OAuthStore.UpdateApp(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateApp", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) AnalyticsPostCount(branchId string, mustHaveFile bool, mustHaveHashtag bool) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCount(branchId, mustHaveFile, mustHaveHashtag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsPostCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCountsByDay(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsPostCountsByDay", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) AnalyticsUserCountsWithPostsByDay(branchId string) (model.AnalyticsRows, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.AnalyticsUserCountsWithPostsByDay(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsUserCountsWithPostsByDay", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) ClearCaches() {
	start := timemodule.Now()

	s.PostStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerPostStore) Delete(postId string, time int64, deleteByID string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PostStore.Delete(postId, time, deleteByID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPostStore) Get(id string, skipFetchThreads bool) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.Get(id, skipFetchThreads)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetEtag(classId string, allowFromCache bool) string {
	start := timemodule.Now()

	resultVar0 := s.PostStore.GetEtag(classId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetEtag", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPostStore) GetFlaggedPosts(userId string, offset int, limit int) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPosts(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPosts", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetFlaggedPostsForBranch(userId string, branchId string, offset int, limit int) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForBranch(userId, branchId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPostsForBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetFlaggedPostsForClass(userId string, classId string, offset int, limit int) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForClass(userId, classId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPostsForClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetMaxPostSize() int {
	start := timemodule.Now()

	resultVar0 := s.PostStore.GetMaxPostSize()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetMaxPostSize", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPostStore) GetOldest() (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetOldest()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetOldest", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostAfterTime(classId string, time int64) (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostAfterTime(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostAfterTime", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostIdAfterTime(classId string, time int64) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostIdAfterTime(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostIdAfterTime", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostIdBeforeTime(classId string, time int64) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostIdBeforeTime(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostIdBeforeTime", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPosts(options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPosts", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsAfter(options model.GetPostsOptions) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsAfter(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsAfter", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.PostForIndexing, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsBatchForIndexing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsBefore(options model.GetPostsOptions) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsBefore(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsBefore", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsByIds(postIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsCreatedAt(classId string, time int64) ([]*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsCreatedAt(classId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsCreatedAt", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetPostsSince(options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsSince", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) GetSingle(id string) (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.GetSingle(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetSingle", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) InvalidateLastPostTimeCache(classId string) {
	start := timemodule.Now()

	s.PostStore.InvalidateLastPostTimeCache(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.InvalidateLastPostTimeCache", success, elapsed)
	}
}

func (s *TimerLayerPostStore) Overwrite(post *model.Post) (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.Overwrite(post)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Overwrite", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) OverwriteMultiple(posts []*model.Post) ([]*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.OverwriteMultiple(posts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.OverwriteMultiple", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteBatch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) PermanentDeleteByClass(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PostStore.PermanentDeleteByClass(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteByClass", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPostStore) PermanentDeleteByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PostStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPostStore) Save(post *model.Post) (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.Save(post)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.SaveMultiple(posts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.SaveMultiple", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) Search(branchId string, userId string, params *model.SearchParams) (*model.PostList, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.Search(branchId, userId, params)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Search", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPostStore) Update(newPost *model.Post, oldPost *model.Post) (*model.Post, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PostStore.Update(newPost, oldPost)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPreferenceStore) Delete(userId string, category string, name string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PreferenceStore.Delete(userId, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userId string, category string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PreferenceStore.DeleteCategory(userId, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPreferenceStore) Get(userId string, category string, name string) (*model.Preference, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PreferenceStore.Get(userId, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPreferenceStore) GetAll(userId string) (model.Preferences, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PreferenceStore.GetAll(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPreferenceStore) GetCategory(userId string, category string) (model.Preferences, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.PreferenceStore.GetCategory(userId, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PreferenceStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerPreferenceStore) Save(preferences *model.Preferences) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.PreferenceStore.Save(preferences)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ReactionStore.BulkGetForPosts(postIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.BulkGetForPosts", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ReactionStore.Delete(reaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Delete", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerReactionStore) DeleteAllWithEmojiName(emojiName string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.DeleteAllWithEmojiName", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerReactionStore) GetForPost(postId string, allowFromCache bool) ([]*model.Reaction, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ReactionStore.GetForPost(postId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetForPost", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.PermanentDeleteBatch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.ReactionStore.Save(reaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) AllClassSchemeRoles() ([]*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.AllClassSchemeRoles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.AllClassSchemeRoles", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) ClassHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.ClassHigherScopedPermissions(roleNames)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.ClassHigherScopedPermissions", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) ClassRolesUnderBranchRole(roleName string) ([]*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.ClassRolesUnderBranchRole(roleName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.ClassRolesUnderBranchRole", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) Delete(roleId string) (*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.Delete(roleId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) Get(roleId string) (*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.Get(roleId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) GetAll() ([]*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) GetByName(name string) (*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) GetByNames(names []string) ([]*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.GetByNames(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerRoleStore) Save(role *model.Role) (*model.Role, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.RoleStore.Save(role)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) CountByScope(scope string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.CountByScope(scope)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountByScope", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountWithoutPermission", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) Delete(schemeId string) (*model.Scheme, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.Delete(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Delete", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) Get(schemeId string) (*model.Scheme, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.Get(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.GetAllPage(scope, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetAllPage", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.GetByName(schemeName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSchemeStore) PermanentDeleteAll() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SchemeStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.PermanentDeleteAll", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SchemeStore.Save(scheme)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {
	start := timemodule.Now()

	s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerSessionStore) Get(sessionIdOrToken string) (*model.Session, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.Get(sessionIdOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) GetSessions(userId string) ([]*model.Session, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.GetSessions(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userId string) ([]*model.Session, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.GetSessionsWithActiveDeviceIds(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(branchId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SessionStore.PermanentDeleteSessionsByUser(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSessionStore) Remove(sessionIdOrToken string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SessionStore.Remove(sessionIdOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSessionStore) RemoveAllSessions() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SessionStore.RemoveAllSessions()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSessionStore) Save(session *model.Session) (*model.Session, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceId string, expiresAt int64) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SessionStore.UpdateLastActivityAt(sessionId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSessionStore) UpdateProps(session *model.Session) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SessionStore.UpdateProps(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSessionStore) UpdateRoles(userId string, roles string) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SessionStore.UpdateRoles(userId, roles)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerStatusStore) Get(userId string) (*model.Status, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.StatusStore.Get(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.StatusStore.GetByIds(userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerStatusStore) ResetAll() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.StatusStore.ResetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerStatusStore) SaveOrUpdate(status *model.Status) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.SaveOrUpdate", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userId string, lastActivityAt int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSystemStore) Get() (model.StringMap, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SystemStore.Get()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SystemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerSystemStore) Save(system *model.System) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SystemStore.Save(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system *model.System) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerSystemStore) Update(system *model.System) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.SystemStore.Update(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerTokenStore) Cleanup() {
	start := timemodule.Now()

	s.TokenStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerTokenStore) Delete(token string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.TokenStore.Delete(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.TokenStore.GetByToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerTokenStore) RemoveAllTokensByType(tokenType string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.RemoveAllTokensByType", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerTokenStore) Save(recovery *model.Token) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.TokenStore.Save(recovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.AnalyticsActiveCount(time, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := timemodule.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options model.UserCountOptions) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) Get(id string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetAll() ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetAllAfter(limit int, afterId string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetAllAfter(limit, afterId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllAfter", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetAllProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetAllProfilesInClass(classId string, allowFromCache bool) (map[string]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetAllProfilesInClass(classId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfilesInClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllUsingAuthService", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByAuth", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetByEmail(email string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetByEmail(email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByEmail", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetByUsername(username string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetByUsername(username)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByUsername", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := timemodule.Now()

	resultVar0 := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) GetEtagForProfiles(branchId string) string {
	start := timemodule.Now()

	resultVar0 := s.UserStore.GetEtagForProfiles(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) GetForLogin(loginId string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetNewUsersForBranch(branchId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetNewUsersForBranch(branchId, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetNewUsersForBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfileByIds(userIds []string, options *UserGetByIdsOpts, allowFromCache bool) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfileByIds(userIds, options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfiles", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesByUsernames", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfilesInClass(classId string, offset int, limit int) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfilesInClass(classId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfilesInClassByStatus(classId string, offset int, limit int) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfilesInClassByStatus(classId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInClassByStatus", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfilesNotInClass(branchId string, classId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfilesNotInClass(branchId, classId, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesNotInClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetProfilesWithoutBranch(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetProfilesWithoutBranch(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesWithoutBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetRecentlyActiveUsersForBranch(branchId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetRecentlyActiveUsersForBranch(branchId, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetRecentlyActiveUsersForBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetUnreadCount(userId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetUnreadCount(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.InferSystemInstallDate()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfileCacheForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInClassCache(classId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfilesInClassCache(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInClassCache", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInClassCacheByUser(userId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfilesInClassCacheByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInClassCacheByUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) PermanentDelete(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.PermanentDelete(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.ResetLastPictureUpdate(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) Save(user *model.User) (*model.User, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.Save(user)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) UpdateAuthData(userId string, service string, authData *string, email string, resetMfa bool) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userId string, attempts int) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.UpdateLastPictureUpdate(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) UpdateMfaActive(userId string, active bool) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.UpdateMfaActive(userId, active)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userId string, secret string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.UpdateMfaSecret(userId, secret)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) UpdatePassword(userId string, newPassword string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserStore.UpdatePassword(userId, newPassword)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.UpdateUpdateAt(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserStore) VerifyEmail(userId string, email string) (string, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserStore.VerifyEmail(userId, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserAccessTokenStore.Delete(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserAccessTokenStore.DeleteAllForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenId string) (*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.Get(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) GetByUser(userId string, page int, perPage int) ([]*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByUser(userId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserAccessTokenStore.Search(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserAccessTokenStore.UpdateTokenDisable(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserAccessTokenStore.UpdateTokenEnable(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserTermsOfServiceStore) Delete(userId string, termsOfServiceId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Delete", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerUserTermsOfServiceStore) GetByUser(userId string) (*model.UserTermsOfService, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.GetByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.GetByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.Save(userTermsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Save", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) AnalyticsIncomingCount(branchId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsIncomingCount(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsIncomingCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) AnalyticsOutgoingCount(branchId string) (int64, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsOutgoingCount(branchId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsOutgoingCount", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) ClearCaches() {
	start := timemodule.Now()

	s.WebhookStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) DeleteIncoming(webhookId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.DeleteIncoming(webhookId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteIncoming", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) DeleteOutgoing(webhookId string, time int64) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.DeleteOutgoing(webhookId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteOutgoing", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncoming(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncoming", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetIncomingByBranch(branchId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByBranch(branchId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetIncomingByBranchByUser(branchId string, userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByBranchByUser(branchId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByBranchByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetIncomingByClass(classId string) ([]*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByClass(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingList(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingList", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetIncomingListByUser(userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingListByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingListByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoing(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingByBranch(branchId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByBranch(branchId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByBranch", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingByBranchByUser(branchId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByBranchByUser(branchId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByBranchByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingByClass(classId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByClass(classId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByClass", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingByClassByUser(classId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByClassByUser(classId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByClassByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingList(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingList", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) GetOutgoingListByUser(userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingListByUser", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) InvalidateWebhookCache(webhook string) {
	start := timemodule.Now()

	s.WebhookStore.InvalidateWebhookCache(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.InvalidateWebhookCache", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByClass(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByClass(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByClass", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByClass(classId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByClass(classId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByClass", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByUser(userId string) *model.AppError {
	start := timemodule.Now()

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar0 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByUser", success, elapsed)
	}
	return resultVar0
}

func (s *TimerLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.SaveIncoming(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveIncoming", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.SaveOutgoing(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveOutgoing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.UpdateIncoming(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateIncoming", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {
	start := timemodule.Now()

	resultVar0, resultVar1 := s.WebhookStore.UpdateOutgoing(hook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if resultVar1 == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateOutgoing", success, elapsed)
	}
	return resultVar0, resultVar1
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) GetCurrentSchemaVersion() string {
	return s.Store.GetCurrentSchemaVersion()
}

func (s *TimerLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *TimerLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *TimerLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *TimerLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *TimerLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func NewTimerLayer(childStore Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BranchStore = &TimerLayerBranchStore{BranchStore: childStore.Branch(), Root: &newStore}
	newStore.ClassStore = &TimerLayerClassStore{ClassStore: childStore.Class(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &TimerLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &TimerLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.EmojiStore = &TimerLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &TimerLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &TimerLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.OAuthStore = &TimerLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.PostStore = &TimerLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ReactionStore = &TimerLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &TimerLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &TimerLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &TimerLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}
